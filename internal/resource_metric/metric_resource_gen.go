// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package resource_metric

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
)

func MetricResourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"custom_roll_up_end": schema.Float64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Custom time window end date in days since exposure.",
				MarkdownDescription: "Custom time window end date in days since exposure.",
			},
			"custom_roll_up_start": schema.Float64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Custom time window start date in days since exposure.",
				MarkdownDescription: "Custom time window start date in days since exposure.",
			},
			"description": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "A description of the new metric, providing context and purpose.",
				MarkdownDescription: "A description of the new metric, providing context and purpose.",
				Validators: []validator.String{
					stringvalidator.LengthAtMost(1000),
				},
			},
			"directionality": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Indicates the desired change direction for the metric. Use \"increase\" for positive changes and \"decrease\" for negative changes.",
				MarkdownDescription: "Indicates the desired change direction for the metric. Use \"increase\" for positive changes and \"decrease\" for negative changes.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"increase",
						"decrease",
					),
				},
				Default: stringdefault.StaticString("increase"),
			},
			"dry_run": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Skips persisting the metric (used to validate that inputs are correct)",
				MarkdownDescription: "Skips persisting the metric (used to validate that inputs are correct)",
			},
			"funnel_count_distinct": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Specifies whether to count events or distinct users for the funnel metric.",
				MarkdownDescription: "Specifies whether to count events or distinct users for the funnel metric.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"events",
						"users",
					),
				},
			},
			"funnel_event_list": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required:            true,
							Description:         "The name of the funnel event used in the metric.",
							MarkdownDescription: "The name of the funnel event used in the metric.",
						},
						"type": schema.StringAttribute{
							Required:            true,
							Description:         "The type of funnel event, specifying how the event is tracked.",
							MarkdownDescription: "The type of funnel event, specifying how the event is tracked.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"event_dau",
									"event_user",
									"event_count",
									"event_count_custom",
								),
							},
						},
					},
					CustomType: FunnelEventListType{
						ObjectType: types.ObjectType{
							AttrTypes: FunnelEventListValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "List of events used to create funnel metrics.",
				MarkdownDescription: "List of events used to create funnel metrics.",
			},
			"id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "id",
				MarkdownDescription: "id",
			},
			"is_permanent": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Indicates whether the metric is permanent and should not be deleted.",
				MarkdownDescription: "Indicates whether the metric is permanent and should not be deleted.",
			},
			"is_read_only": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Set to true to make the metric definition editable only from the Console API.",
				MarkdownDescription: "Set to true to make the metric definition editable only from the Console API.",
			},
			"is_verified": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Marks the metric as verified for internal trustworthiness.",
				MarkdownDescription: "Marks the metric as verified for internal trustworthiness.",
			},
			"metric_component_metrics": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"name": schema.StringAttribute{
							Required: true,
						},
						"type": schema.StringAttribute{
							Required: true,
						},
					},
					CustomType: MetricComponentMetricsType{
						ObjectType: types.ObjectType{
							AttrTypes: MetricComponentMetricsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "List of input metrics used to calculate the new metric for composite types.",
				MarkdownDescription: "List of input metrics used to calculate the new metric for composite types.",
			},
			"metric_events": schema.ListNestedAttribute{
				NestedObject: schema.NestedAttributeObject{
					Attributes: map[string]schema.Attribute{
						"criteria": schema.ListNestedAttribute{
							NestedObject: schema.NestedAttributeObject{
								Attributes: map[string]schema.Attribute{
									"column": schema.StringAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "Optional column specifying which data attribute to filter on.",
										MarkdownDescription: "Optional column specifying which data attribute to filter on.",
									},
									"condition": schema.StringAttribute{
										Required:            true,
										Description:         "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
										MarkdownDescription: "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"in",
												"not_in",
												"=",
												">",
												"<",
												">=",
												"<=",
												"is_null",
												"non_null",
												"contains",
												"not_contains",
												"sql_filter",
												"starts_with",
												"ends_with",
												"after_exposure",
												"is_true",
												"is_false",
											),
										},
									},
									"null_vacuous_override": schema.BoolAttribute{
										Optional:            true,
										Computed:            true,
										Description:         "If true, overrides null values in criterion evaluation.",
										MarkdownDescription: "If true, overrides null values in criterion evaluation.",
									},
									"type": schema.StringAttribute{
										Required:            true,
										Description:         "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
										MarkdownDescription: "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
										Validators: []validator.String{
											stringvalidator.OneOf(
												"value",
												"metadata",
												"user",
												"user_custom",
											),
										},
									},
									"values": schema.ListAttribute{
										ElementType:         types.StringType,
										Optional:            true,
										Computed:            true,
										Description:         "Optional array of values for the criterion to match against.",
										MarkdownDescription: "Optional array of values for the criterion to match against.",
									},
								},
								CustomType: CriteriaType{
									ObjectType: types.ObjectType{
										AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
									},
								},
							},
							Optional:            true,
							Computed:            true,
							Description:         "Filtering criteria for the metric event, including conditions and values to refine the event data.",
							MarkdownDescription: "Filtering criteria for the metric event, including conditions and values to refine the event data.",
						},
						"metadata_key": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The key for associated metadata, if applicable.",
							MarkdownDescription: "The key for associated metadata, if applicable.",
						},
						"name": schema.StringAttribute{
							Required:            true,
							Description:         "The name of the metric event.",
							MarkdownDescription: "The name of the metric event.",
						},
						"type": schema.StringAttribute{
							Optional:            true,
							Computed:            true,
							Description:         "The type of metric event. Allowed values include: count, count_distinct, value, and metadata.",
							MarkdownDescription: "The type of metric event. Allowed values include: count, count_distinct, value, and metadata.",
							Validators: []validator.String{
								stringvalidator.OneOf(
									"count",
									"count_distinct",
									"value",
									"metadata",
								),
							},
						},
					},
					CustomType: MetricEventsType{
						ObjectType: types.ObjectType{
							AttrTypes: MetricEventsValue{}.AttributeTypes(ctx),
						},
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "An array of event definitions used to compute the metric.",
				MarkdownDescription: "An array of event definitions used to compute the metric.",
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "The name of the new metric, which identifies it within the system.",
				MarkdownDescription: "The name of the new metric, which identifies it within the system.",
				Validators: []validator.String{
					stringvalidator.LengthBetween(4, 200),
					stringvalidator.RegexMatches(regexp.MustCompile("^[a-zA-Z0-9_.\\-()/ %:]*$"), ""),
				},
			},
			"rollup_time_window": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Time window for the metric rollup. Specify \"custom\" for a customized time window.",
				MarkdownDescription: "Time window for the metric rollup. Specify \"custom\" for a customized time window.",
			},
			"tags": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Tags associated with the metric for categorization and searchability.",
				MarkdownDescription: "Tags associated with the metric for categorization and searchability.",
			},
			"team": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The team associated with the metric, applicable for enterprise environments.",
				MarkdownDescription: "The team associated with the metric, applicable for enterprise environments.",
			},
			"team_id": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "The team ID associated with the metric, applicable for enterprise environments.",
				MarkdownDescription: "The team ID associated with the metric, applicable for enterprise environments.",
			},
			"type": schema.StringAttribute{
				Required:            true,
				Description:         "The type of the metric. Allowed values include sum, ratio, mean, event_count_sum, composite, composite_sum, undefined, funnel, user_warehouse.",
				MarkdownDescription: "The type of the metric. Allowed values include sum, ratio, mean, event_count_sum, composite, composite_sum, undefined, funnel, user_warehouse.",
				Validators: []validator.String{
					stringvalidator.OneOf(
						"ratio",
						"sum",
						"composite",
						"mean",
						"event_count_custom",
						"event_user",
						"funnel",
						"undefined",
						"setup_incomplete",
						"composite_sum",
						"import_window",
						"user_warehouse",
					),
				},
			},
			"unit_types": schema.ListAttribute{
				ElementType:         types.StringType,
				Optional:            true,
				Computed:            true,
				Description:         "Array of unit types associated with the metric, such as stableID or userID.",
				MarkdownDescription: "Array of unit types associated with the metric, such as stableID or userID.",
			},
			"warehouse_native": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"aggregation": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile",
						MarkdownDescription: "Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"count",
								"sum",
								"mean",
								"daily_participation",
								"ratio",
								"funnel",
								"count_distinct",
								"percentile",
								"first_value",
								"latest_value",
								"retention",
								"max",
								"min",
								"",
							),
						},
					},
					"allow_null_ratio_denominator": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Include units which do not have a denominator. Only applicable to ratios.",
						MarkdownDescription: "Include units which do not have a denominator. Only applicable to ratios.",
					},
					"cap": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Maximum cap for metric values.",
						MarkdownDescription: "Maximum cap for metric values.",
					},
					"criteria": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"column": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Optional column specifying which data attribute to filter on.",
									MarkdownDescription: "Optional column specifying which data attribute to filter on.",
								},
								"condition": schema.StringAttribute{
									Required:            true,
									Description:         "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
									MarkdownDescription: "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"in",
											"not_in",
											"=",
											">",
											"<",
											">=",
											"<=",
											"is_null",
											"non_null",
											"contains",
											"not_contains",
											"sql_filter",
											"starts_with",
											"ends_with",
											"after_exposure",
											"is_true",
											"is_false",
										),
									},
								},
								"null_vacuous_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "If true, overrides null values in criterion evaluation.",
									MarkdownDescription: "If true, overrides null values in criterion evaluation.",
								},
								"type": schema.StringAttribute{
									Required:            true,
									Description:         "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
									MarkdownDescription: "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"value",
											"metadata",
											"user",
											"user_custom",
										),
									},
								},
								"values": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "Optional array of values for the criterion to match against.",
									MarkdownDescription: "Optional array of values for the criterion to match against.",
								},
							},
							CustomType: CriteriaType{
								ObjectType: types.ObjectType{
									AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Filtering criteria for the metric source",
						MarkdownDescription: "Filtering criteria for the metric source",
					},
					"cuped_attribution_window": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Attribution window for CUPED adjustments in days.",
						MarkdownDescription: "Attribution window for CUPED adjustments in days.",
					},
					"custom_roll_up_end": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Custom end date for rollup in days since exposure.",
						MarkdownDescription: "Custom end date for rollup in days since exposure.",
					},
					"custom_roll_up_start": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Custom start date for rollup in days since exposure.",
						MarkdownDescription: "Custom start date for rollup in days since exposure.",
					},
					"denominator_aggregation": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile",
						MarkdownDescription: "Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"count",
								"sum",
								"mean",
								"daily_participation",
								"ratio",
								"funnel",
								"count_distinct",
								"percentile",
								"first_value",
								"latest_value",
								"retention",
								"max",
								"min",
								"",
							),
						},
					},
					"denominator_criteria": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"column": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Optional column specifying which data attribute to filter on.",
									MarkdownDescription: "Optional column specifying which data attribute to filter on.",
								},
								"condition": schema.StringAttribute{
									Required:            true,
									Description:         "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
									MarkdownDescription: "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"in",
											"not_in",
											"=",
											">",
											"<",
											">=",
											"<=",
											"is_null",
											"non_null",
											"contains",
											"not_contains",
											"sql_filter",
											"starts_with",
											"ends_with",
											"after_exposure",
											"is_true",
											"is_false",
										),
									},
								},
								"null_vacuous_override": schema.BoolAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "If true, overrides null values in criterion evaluation.",
									MarkdownDescription: "If true, overrides null values in criterion evaluation.",
								},
								"type": schema.StringAttribute{
									Required:            true,
									Description:         "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
									MarkdownDescription: "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
									Validators: []validator.String{
										stringvalidator.OneOf(
											"value",
											"metadata",
											"user",
											"user_custom",
										),
									},
								},
								"values": schema.ListAttribute{
									ElementType:         types.StringType,
									Optional:            true,
									Computed:            true,
									Description:         "Optional array of values for the criterion to match against.",
									MarkdownDescription: "Optional array of values for the criterion to match against.",
								},
							},
							CustomType: DenominatorCriteriaType{
								ObjectType: types.ObjectType{
									AttrTypes: DenominatorCriteriaValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "Filtering criteria for the denominator metric source, if this metric is a ratio",
						MarkdownDescription: "Filtering criteria for the denominator metric source, if this metric is a ratio",
					},
					"denominator_custom_rollup_end": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Custom end date for rollup in days since exposure.",
						MarkdownDescription: "Custom end date for rollup in days since exposure.",
					},
					"denominator_custom_rollup_start": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Custom start date for rollup in days since exposure.",
						MarkdownDescription: "Custom start date for rollup in days since exposure.",
					},
					"denominator_metric_source_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Name of the metric source for the denominator.",
						MarkdownDescription: "Name of the metric source for the denominator.",
					},
					"denominator_rollup_time_window": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Time window for the denominator metric. Specify \"custom\" for a custom window.",
						MarkdownDescription: "Time window for the denominator metric. Specify \"custom\" for a custom window.",
					},
					"denominator_value_column": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Column name for the denominator’s value.",
						MarkdownDescription: "Column name for the denominator’s value.",
					},
					"funnel_calculation_window": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Duration for counting funnel events in days.",
						MarkdownDescription: "Duration for counting funnel events in days.",
					},
					"funnel_count_distinct": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Allowed: users┃sessions for distinct count method in funnel events.",
						MarkdownDescription: "Allowed: users┃sessions for distinct count method in funnel events.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"sessions",
								"users",
							),
						},
					},
					"funnel_events": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"criteria": schema.ListNestedAttribute{
									NestedObject: schema.NestedAttributeObject{
										Attributes: map[string]schema.Attribute{
											"column": schema.StringAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "Optional column specifying which data attribute to filter on.",
												MarkdownDescription: "Optional column specifying which data attribute to filter on.",
											},
											"condition": schema.StringAttribute{
												Required:            true,
												Description:         "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
												MarkdownDescription: "sql_filter, start_withs, ends_with, and after_exposure are only applicable in Warehouse Native",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"in",
														"not_in",
														"=",
														">",
														"<",
														">=",
														"<=",
														"is_null",
														"non_null",
														"contains",
														"not_contains",
														"sql_filter",
														"starts_with",
														"ends_with",
														"after_exposure",
														"is_true",
														"is_false",
													),
												},
											},
											"null_vacuous_override": schema.BoolAttribute{
												Optional:            true,
												Computed:            true,
												Description:         "If true, overrides null values in criterion evaluation.",
												MarkdownDescription: "If true, overrides null values in criterion evaluation.",
											},
											"type": schema.StringAttribute{
												Required:            true,
												Description:         "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
												MarkdownDescription: "Type of event criterion for filtering metrics. Options include `value`, `metadata`, `user`, and `user_custom`; in Warehouse Native, this should always be `metadata`.",
												Validators: []validator.String{
													stringvalidator.OneOf(
														"value",
														"metadata",
														"user",
														"user_custom",
													),
												},
											},
											"values": schema.ListAttribute{
												ElementType:         types.StringType,
												Optional:            true,
												Computed:            true,
												Description:         "Optional array of values for the criterion to match against.",
												MarkdownDescription: "Optional array of values for the criterion to match against.",
											},
										},
										CustomType: CriteriaType{
											ObjectType: types.ObjectType{
												AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
											},
										},
									},
									Optional:            true,
									Computed:            true,
									Description:         "Optional array of criteria to filter the funnel events, defined by various types and conditions.",
									MarkdownDescription: "Optional array of criteria to filter the funnel events, defined by various types and conditions.",
								},
								"metric_source_name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Optional name of the metric source associated with the funnel event.",
									MarkdownDescription: "Optional name of the metric source associated with the funnel event.",
								},
								"name": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Optional step name for the funnel event, can be null if not specified.",
									MarkdownDescription: "Optional step name for the funnel event, can be null if not specified.",
								},
								"session_identifier_field": schema.StringAttribute{
									Optional:            true,
									Computed:            true,
									Description:         "Name of column which being used as session identifier. Funnel event with the same metric source",
									MarkdownDescription: "Name of column which being used as session identifier. Funnel event with the same metric source",
								},
							},
							CustomType: FunnelEventsType{
								ObjectType: types.ObjectType{
									AttrTypes: FunnelEventsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Optional:            true,
						Computed:            true,
						Description:         "List of funnel events with associated criteria and identifiers.",
						MarkdownDescription: "List of funnel events with associated criteria and identifiers.",
					},
					"funnel_start_criteria": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Allowed: start_event┃exposure to determine funnel start criteria.",
						MarkdownDescription: "Allowed: start_event┃exposure to determine funnel start criteria.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"start_event",
								"exposure",
							),
						},
					},
					"metric_bake_days": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Number of days for metric baking; specify duration for analysis.",
						MarkdownDescription: "Number of days for metric baking; specify duration for analysis.",
					},
					"metric_dimension_columns": schema.ListAttribute{
						ElementType:         types.StringType,
						Optional:            true,
						Computed:            true,
						Description:         "Specify metadata columns for breaking down metric analysis.",
						MarkdownDescription: "Specify metadata columns for breaking down metric analysis.",
					},
					"metric_source_name": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "For Count, Sum, Mean, User Count aggregation types: the name of metric source",
						MarkdownDescription: "For Count, Sum, Mean, User Count aggregation types: the name of metric source",
					},
					"numerator_aggregation": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Aggregation type for numerator; Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile.",
						MarkdownDescription: "Aggregation type for numerator; Allowed: count┃sum┃mean┃daily_participation┃ratio┃funnel┃count_distinct┃percentile.",
						Validators: []validator.String{
							stringvalidator.OneOf(
								"count",
								"sum",
								"mean",
								"daily_participation",
								"ratio",
								"funnel",
								"count_distinct",
								"percentile",
								"first_value",
								"latest_value",
								"retention",
								"max",
								"min",
								"",
							),
						},
					},
					"only_include_users_with_conversion_event": schema.BoolAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Flag to include only users with a conversion event in the metric.",
						MarkdownDescription: "Flag to include only users with a conversion event in the metric.",
					},
					"percentile": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Percentile value for statistical calculations.",
						MarkdownDescription: "Percentile value for statistical calculations.",
					},
					"rollup_time_window": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "General time window for rollup; can specify custom settings.",
						MarkdownDescription: "General time window for rollup; can specify custom settings.",
					},
					"value_column": schema.StringAttribute{
						Optional:            true,
						Computed:            true,
						Description:         "Column name representing the metric’s value.",
						MarkdownDescription: "Column name representing the metric’s value.",
					},
					"value_threshold": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Threshold value for filtering metrics.",
						MarkdownDescription: "Threshold value for filtering metrics.",
					},
					"wait_for_cohort_window": schema.BoolAttribute{
						Optional: true,
						Computed: true,
					},
					"winsorization_high": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "High threshold for winsorization; must be between 0 and 1.",
						MarkdownDescription: "High threshold for winsorization; must be between 0 and 1.",
					},
					"winsorization_low": schema.Float64Attribute{
						Optional:            true,
						Computed:            true,
						Description:         "Low threshold for winsorization; must be between 0 and 1.",
						MarkdownDescription: "Low threshold for winsorization; must be between 0 and 1.",
					},
				},
				CustomType: WarehouseNativeType{
					ObjectType: types.ObjectType{
						AttrTypes: WarehouseNativeValue{}.AttributeTypes(ctx),
					},
				},
				Optional:            true,
				Computed:            true,
				Description:         "Defines warehouse native metrics for advanced configurations.",
				MarkdownDescription: "Defines warehouse native metrics for advanced configurations.",
			},
		},
	}
}

type MetricModel struct {
	CustomRollUpEnd        types.Float64        `tfsdk:"custom_roll_up_end"`
	CustomRollUpStart      types.Float64        `tfsdk:"custom_roll_up_start"`
	Description            types.String         `tfsdk:"description"`
	Directionality         types.String         `tfsdk:"directionality"`
	DryRun                 types.Bool           `tfsdk:"dry_run"`
	FunnelCountDistinct    types.String         `tfsdk:"funnel_count_distinct"`
	FunnelEventList        types.List           `tfsdk:"funnel_event_list"`
	Id                     types.String         `tfsdk:"id"`
	IsPermanent            types.Bool           `tfsdk:"is_permanent"`
	IsReadOnly             types.Bool           `tfsdk:"is_read_only"`
	IsVerified             types.Bool           `tfsdk:"is_verified"`
	MetricComponentMetrics types.List           `tfsdk:"metric_component_metrics"`
	MetricEvents           types.List           `tfsdk:"metric_events"`
	Name                   types.String         `tfsdk:"name"`
	RollupTimeWindow       types.String         `tfsdk:"rollup_time_window"`
	Tags                   types.List           `tfsdk:"tags"`
	Team                   types.String         `tfsdk:"team"`
	TeamId                 types.String         `tfsdk:"team_id"`
	Type                   types.String         `tfsdk:"type"`
	UnitTypes              types.List           `tfsdk:"unit_types"`
	WarehouseNative        WarehouseNativeValue `tfsdk:"warehouse_native"`
}

var _ basetypes.ObjectTypable = FunnelEventListType{}

type FunnelEventListType struct {
	basetypes.ObjectType
}

func (t FunnelEventListType) Equal(o attr.Type) bool {
	other, ok := o.(FunnelEventListType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FunnelEventListType) String() string {
	return "FunnelEventListType"
}

func (t FunnelEventListType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FunnelEventListValue{
		Name:                nameVal,
		FunnelEventListType: typeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewFunnelEventListValueNull() FunnelEventListValue {
	return FunnelEventListValue{
		state: attr.ValueStateNull,
	}
}

func NewFunnelEventListValueUnknown() FunnelEventListValue {
	return FunnelEventListValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFunnelEventListValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FunnelEventListValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FunnelEventListValue Attribute Value",
				"While creating a FunnelEventListValue value, a missing attribute value was detected. "+
					"A FunnelEventListValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FunnelEventListValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FunnelEventListValue Attribute Type",
				"While creating a FunnelEventListValue value, an invalid attribute value was detected. "+
					"A FunnelEventListValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FunnelEventListValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FunnelEventListValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FunnelEventListValue Attribute Value",
				"While creating a FunnelEventListValue value, an extra attribute value was detected. "+
					"A FunnelEventListValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FunnelEventListValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFunnelEventListValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFunnelEventListValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewFunnelEventListValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewFunnelEventListValueUnknown(), diags
	}

	return FunnelEventListValue{
		Name:                nameVal,
		FunnelEventListType: typeVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewFunnelEventListValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FunnelEventListValue {
	object, diags := NewFunnelEventListValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFunnelEventListValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FunnelEventListType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFunnelEventListValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFunnelEventListValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFunnelEventListValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFunnelEventListValueMust(FunnelEventListValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FunnelEventListType) ValueType(ctx context.Context) attr.Value {
	return FunnelEventListValue{}
}

var _ basetypes.ObjectValuable = FunnelEventListValue{}

type FunnelEventListValue struct {
	Name                basetypes.StringValue `tfsdk:"name"`
	FunnelEventListType basetypes.StringValue `tfsdk:"type"`
	state               attr.ValueState
}

func (v FunnelEventListValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.FunnelEventListType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FunnelEventListValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FunnelEventListValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FunnelEventListValue) String() string {
	return "FunnelEventListValue"
}

func (v FunnelEventListValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": basetypes.StringType{},
			"type": basetypes.StringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
			"type": v.FunnelEventListType,
		})

	return objVal, diags
}

func (v FunnelEventListValue) Equal(o attr.Value) bool {
	other, ok := o.(FunnelEventListValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.FunnelEventListType.Equal(other.FunnelEventListType) {
		return false
	}

	return true
}

func (v FunnelEventListValue) Type(ctx context.Context) attr.Type {
	return FunnelEventListType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FunnelEventListValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetricComponentMetricsType{}

type MetricComponentMetricsType struct {
	basetypes.ObjectType
}

func (t MetricComponentMetricsType) Equal(o attr.Type) bool {
	other, ok := o.(MetricComponentMetricsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetricComponentMetricsType) String() string {
	return "MetricComponentMetricsType"
}

func (t MetricComponentMetricsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetricComponentMetricsValue{
		Name:                       nameVal,
		MetricComponentMetricsType: typeVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewMetricComponentMetricsValueNull() MetricComponentMetricsValue {
	return MetricComponentMetricsValue{
		state: attr.ValueStateNull,
	}
}

func NewMetricComponentMetricsValueUnknown() MetricComponentMetricsValue {
	return MetricComponentMetricsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetricComponentMetricsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetricComponentMetricsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetricComponentMetricsValue Attribute Value",
				"While creating a MetricComponentMetricsValue value, a missing attribute value was detected. "+
					"A MetricComponentMetricsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricComponentMetricsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetricComponentMetricsValue Attribute Type",
				"While creating a MetricComponentMetricsValue value, an invalid attribute value was detected. "+
					"A MetricComponentMetricsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricComponentMetricsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetricComponentMetricsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetricComponentMetricsValue Attribute Value",
				"While creating a MetricComponentMetricsValue value, an extra attribute value was detected. "+
					"A MetricComponentMetricsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetricComponentMetricsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetricComponentMetricsValueUnknown(), diags
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetricComponentMetricsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewMetricComponentMetricsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewMetricComponentMetricsValueUnknown(), diags
	}

	return MetricComponentMetricsValue{
		Name:                       nameVal,
		MetricComponentMetricsType: typeVal,
		state:                      attr.ValueStateKnown,
	}, diags
}

func NewMetricComponentMetricsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetricComponentMetricsValue {
	object, diags := NewMetricComponentMetricsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetricComponentMetricsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetricComponentMetricsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetricComponentMetricsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetricComponentMetricsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetricComponentMetricsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetricComponentMetricsValueMust(MetricComponentMetricsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetricComponentMetricsType) ValueType(ctx context.Context) attr.Value {
	return MetricComponentMetricsValue{}
}

var _ basetypes.ObjectValuable = MetricComponentMetricsValue{}

type MetricComponentMetricsValue struct {
	Name                       basetypes.StringValue `tfsdk:"name"`
	MetricComponentMetricsType basetypes.StringValue `tfsdk:"type"`
	state                      attr.ValueState
}

func (v MetricComponentMetricsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 2)

	var val tftypes.Value
	var err error

	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 2)

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.MetricComponentMetricsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetricComponentMetricsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetricComponentMetricsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetricComponentMetricsValue) String() string {
	return "MetricComponentMetricsValue"
}

func (v MetricComponentMetricsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"name": basetypes.StringType{},
			"type": basetypes.StringType{},
		},
		map[string]attr.Value{
			"name": v.Name,
			"type": v.MetricComponentMetricsType,
		})

	return objVal, diags
}

func (v MetricComponentMetricsValue) Equal(o attr.Value) bool {
	other, ok := o.(MetricComponentMetricsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.MetricComponentMetricsType.Equal(other.MetricComponentMetricsType) {
		return false
	}

	return true
}

func (v MetricComponentMetricsValue) Type(ctx context.Context) attr.Type {
	return MetricComponentMetricsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetricComponentMetricsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"name": basetypes.StringType{},
		"type": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = MetricEventsType{}

type MetricEventsType struct {
	basetypes.ObjectType
}

func (t MetricEventsType) Equal(o attr.Type) bool {
	other, ok := o.(MetricEventsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t MetricEventsType) String() string {
	return "MetricEventsType"
}

func (t MetricEventsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return nil, diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	metadataKeyAttribute, ok := attributes["metadata_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata_key is missing from object`)

		return nil, diags
	}

	metadataKeyVal, ok := metadataKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata_key expected to be basetypes.StringValue, was: %T`, metadataKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return MetricEventsValue{
		Criteria:         criteriaVal,
		MetadataKey:      metadataKeyVal,
		Name:             nameVal,
		MetricEventsType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetricEventsValueNull() MetricEventsValue {
	return MetricEventsValue{
		state: attr.ValueStateNull,
	}
}

func NewMetricEventsValueUnknown() MetricEventsValue {
	return MetricEventsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewMetricEventsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (MetricEventsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing MetricEventsValue Attribute Value",
				"While creating a MetricEventsValue value, a missing attribute value was detected. "+
					"A MetricEventsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricEventsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid MetricEventsValue Attribute Type",
				"While creating a MetricEventsValue value, an invalid attribute value was detected. "+
					"A MetricEventsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("MetricEventsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("MetricEventsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra MetricEventsValue Attribute Value",
				"While creating a MetricEventsValue value, an extra attribute value was detected. "+
					"A MetricEventsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra MetricEventsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewMetricEventsValueUnknown(), diags
	}

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return NewMetricEventsValueUnknown(), diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	metadataKeyAttribute, ok := attributes["metadata_key"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metadata_key is missing from object`)

		return NewMetricEventsValueUnknown(), diags
	}

	metadataKeyVal, ok := metadataKeyAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metadata_key expected to be basetypes.StringValue, was: %T`, metadataKeyAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewMetricEventsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewMetricEventsValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	if diags.HasError() {
		return NewMetricEventsValueUnknown(), diags
	}

	return MetricEventsValue{
		Criteria:         criteriaVal,
		MetadataKey:      metadataKeyVal,
		Name:             nameVal,
		MetricEventsType: typeVal,
		state:            attr.ValueStateKnown,
	}, diags
}

func NewMetricEventsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) MetricEventsValue {
	object, diags := NewMetricEventsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewMetricEventsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t MetricEventsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewMetricEventsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewMetricEventsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewMetricEventsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewMetricEventsValueMust(MetricEventsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t MetricEventsType) ValueType(ctx context.Context) attr.Value {
	return MetricEventsValue{}
}

var _ basetypes.ObjectValuable = MetricEventsValue{}

type MetricEventsValue struct {
	Criteria         basetypes.ListValue   `tfsdk:"criteria"`
	MetadataKey      basetypes.StringValue `tfsdk:"metadata_key"`
	Name             basetypes.StringValue `tfsdk:"name"`
	MetricEventsType basetypes.StringValue `tfsdk:"type"`
	state            attr.ValueState
}

func (v MetricEventsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["criteria"] = basetypes.ListType{
		ElemType: CriteriaValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["metadata_key"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Criteria.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["criteria"] = val

		val, err = v.MetadataKey.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metadata_key"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.MetricEventsType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v MetricEventsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v MetricEventsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v MetricEventsValue) String() string {
	return "MetricEventsValue"
}

func (v MetricEventsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	criteria := types.ListValueMust(
		CriteriaType{
			basetypes.ObjectType{
				AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
			},
		},
		v.Criteria.Elements(),
	)

	if v.Criteria.IsNull() {
		criteria = types.ListNull(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Criteria.IsUnknown() {
		criteria = types.ListUnknown(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"criteria": basetypes.ListType{
				ElemType: CriteriaValue{}.Type(ctx),
			},
			"metadata_key": basetypes.StringType{},
			"name":         basetypes.StringType{},
			"type":         basetypes.StringType{},
		},
		map[string]attr.Value{
			"criteria":     criteria,
			"metadata_key": v.MetadataKey,
			"name":         v.Name,
			"type":         v.MetricEventsType,
		})

	return objVal, diags
}

func (v MetricEventsValue) Equal(o attr.Value) bool {
	other, ok := o.(MetricEventsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Criteria.Equal(other.Criteria) {
		return false
	}

	if !v.MetadataKey.Equal(other.MetadataKey) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.MetricEventsType.Equal(other.MetricEventsType) {
		return false
	}

	return true
}

func (v MetricEventsValue) Type(ctx context.Context) attr.Type {
	return MetricEventsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v MetricEventsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"criteria": basetypes.ListType{
			ElemType: CriteriaValue{}.Type(ctx),
		},
		"metadata_key": basetypes.StringType{},
		"name":         basetypes.StringType{},
		"type":         basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CriteriaType{}

type CriteriaType struct {
	basetypes.ObjectType
}

func (t CriteriaType) Equal(o attr.Type) bool {
	other, ok := o.(CriteriaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CriteriaType) String() string {
	return "CriteriaType"
}

func (t CriteriaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return nil, diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return nil, diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueNull() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateNull,
	}
}

func NewCriteriaValueUnknown() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCriteriaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CriteriaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, a missing attribute value was detected. "+
					"A CriteriaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CriteriaValue Attribute Type",
				"While creating a CriteriaValue value, an invalid attribute value was detected. "+
					"A CriteriaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, an extra attribute value was detected. "+
					"A CriteriaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CriteriaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CriteriaValue {
	object, diags := NewCriteriaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCriteriaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CriteriaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCriteriaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCriteriaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCriteriaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCriteriaValueMust(CriteriaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CriteriaType) ValueType(ctx context.Context) attr.Value {
	return CriteriaValue{}
}

var _ basetypes.ObjectValuable = CriteriaValue{}

type CriteriaValue struct {
	Column              basetypes.StringValue `tfsdk:"column"`
	Condition           basetypes.StringValue `tfsdk:"condition"`
	NullVacuousOverride basetypes.BoolValue   `tfsdk:"null_vacuous_override"`
	CriteriaType        basetypes.StringValue `tfsdk:"type"`
	Values              basetypes.ListValue   `tfsdk:"values"`
	state               attr.ValueState
}

func (v CriteriaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["null_vacuous_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Column.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["column"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.NullVacuousOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["null_vacuous_override"] = val

		val, err = v.CriteriaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CriteriaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CriteriaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CriteriaValue) String() string {
	return "CriteriaValue"
}

func (v CriteriaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	valuesVal, d := types.ListValue(types.StringType, v.Values.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"column":                v.Column,
			"condition":             v.Condition,
			"null_vacuous_override": v.NullVacuousOverride,
			"type":                  v.CriteriaType,
			"values":                valuesVal,
		})

	return objVal, diags
}

func (v CriteriaValue) Equal(o attr.Value) bool {
	other, ok := o.(CriteriaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Column.Equal(other.Column) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.NullVacuousOverride.Equal(other.NullVacuousOverride) {
		return false
	}

	if !v.CriteriaType.Equal(other.CriteriaType) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v CriteriaValue) Type(ctx context.Context) attr.Type {
	return CriteriaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CriteriaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"column":                basetypes.StringType{},
		"condition":             basetypes.StringType{},
		"null_vacuous_override": basetypes.BoolType{},
		"type":                  basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = WarehouseNativeType{}

type WarehouseNativeType struct {
	basetypes.ObjectType
}

func (t WarehouseNativeType) Equal(o attr.Type) bool {
	other, ok := o.(WarehouseNativeType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t WarehouseNativeType) String() string {
	return "WarehouseNativeType"
}

func (t WarehouseNativeType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return nil, diags
	}

	aggregationVal, ok := aggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be basetypes.StringValue, was: %T`, aggregationAttribute))
	}

	allowNullRatioDenominatorAttribute, ok := attributes["allow_null_ratio_denominator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_null_ratio_denominator is missing from object`)

		return nil, diags
	}

	allowNullRatioDenominatorVal, ok := allowNullRatioDenominatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_null_ratio_denominator expected to be basetypes.BoolValue, was: %T`, allowNullRatioDenominatorAttribute))
	}

	capAttribute, ok := attributes["cap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cap is missing from object`)

		return nil, diags
	}

	capVal, ok := capAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cap expected to be basetypes.Float64Value, was: %T`, capAttribute))
	}

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return nil, diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	cupedAttributionWindowAttribute, ok := attributes["cuped_attribution_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cuped_attribution_window is missing from object`)

		return nil, diags
	}

	cupedAttributionWindowVal, ok := cupedAttributionWindowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cuped_attribution_window expected to be basetypes.Float64Value, was: %T`, cupedAttributionWindowAttribute))
	}

	customRollUpEndAttribute, ok := attributes["custom_roll_up_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_roll_up_end is missing from object`)

		return nil, diags
	}

	customRollUpEndVal, ok := customRollUpEndAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_roll_up_end expected to be basetypes.Float64Value, was: %T`, customRollUpEndAttribute))
	}

	customRollUpStartAttribute, ok := attributes["custom_roll_up_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_roll_up_start is missing from object`)

		return nil, diags
	}

	customRollUpStartVal, ok := customRollUpStartAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_roll_up_start expected to be basetypes.Float64Value, was: %T`, customRollUpStartAttribute))
	}

	denominatorAggregationAttribute, ok := attributes["denominator_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_aggregation is missing from object`)

		return nil, diags
	}

	denominatorAggregationVal, ok := denominatorAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_aggregation expected to be basetypes.StringValue, was: %T`, denominatorAggregationAttribute))
	}

	denominatorCriteriaAttribute, ok := attributes["denominator_criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_criteria is missing from object`)

		return nil, diags
	}

	denominatorCriteriaVal, ok := denominatorCriteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_criteria expected to be basetypes.ListValue, was: %T`, denominatorCriteriaAttribute))
	}

	denominatorCustomRollupEndAttribute, ok := attributes["denominator_custom_rollup_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_custom_rollup_end is missing from object`)

		return nil, diags
	}

	denominatorCustomRollupEndVal, ok := denominatorCustomRollupEndAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_custom_rollup_end expected to be basetypes.Float64Value, was: %T`, denominatorCustomRollupEndAttribute))
	}

	denominatorCustomRollupStartAttribute, ok := attributes["denominator_custom_rollup_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_custom_rollup_start is missing from object`)

		return nil, diags
	}

	denominatorCustomRollupStartVal, ok := denominatorCustomRollupStartAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_custom_rollup_start expected to be basetypes.Float64Value, was: %T`, denominatorCustomRollupStartAttribute))
	}

	denominatorMetricSourceNameAttribute, ok := attributes["denominator_metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_metric_source_name is missing from object`)

		return nil, diags
	}

	denominatorMetricSourceNameVal, ok := denominatorMetricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_metric_source_name expected to be basetypes.StringValue, was: %T`, denominatorMetricSourceNameAttribute))
	}

	denominatorRollupTimeWindowAttribute, ok := attributes["denominator_rollup_time_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_rollup_time_window is missing from object`)

		return nil, diags
	}

	denominatorRollupTimeWindowVal, ok := denominatorRollupTimeWindowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_rollup_time_window expected to be basetypes.StringValue, was: %T`, denominatorRollupTimeWindowAttribute))
	}

	denominatorValueColumnAttribute, ok := attributes["denominator_value_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_value_column is missing from object`)

		return nil, diags
	}

	denominatorValueColumnVal, ok := denominatorValueColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_value_column expected to be basetypes.StringValue, was: %T`, denominatorValueColumnAttribute))
	}

	funnelCalculationWindowAttribute, ok := attributes["funnel_calculation_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_calculation_window is missing from object`)

		return nil, diags
	}

	funnelCalculationWindowVal, ok := funnelCalculationWindowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_calculation_window expected to be basetypes.Float64Value, was: %T`, funnelCalculationWindowAttribute))
	}

	funnelCountDistinctAttribute, ok := attributes["funnel_count_distinct"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_count_distinct is missing from object`)

		return nil, diags
	}

	funnelCountDistinctVal, ok := funnelCountDistinctAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_count_distinct expected to be basetypes.StringValue, was: %T`, funnelCountDistinctAttribute))
	}

	funnelEventsAttribute, ok := attributes["funnel_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_events is missing from object`)

		return nil, diags
	}

	funnelEventsVal, ok := funnelEventsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_events expected to be basetypes.ListValue, was: %T`, funnelEventsAttribute))
	}

	funnelStartCriteriaAttribute, ok := attributes["funnel_start_criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_start_criteria is missing from object`)

		return nil, diags
	}

	funnelStartCriteriaVal, ok := funnelStartCriteriaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_start_criteria expected to be basetypes.StringValue, was: %T`, funnelStartCriteriaAttribute))
	}

	metricBakeDaysAttribute, ok := attributes["metric_bake_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_bake_days is missing from object`)

		return nil, diags
	}

	metricBakeDaysVal, ok := metricBakeDaysAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_bake_days expected to be basetypes.Float64Value, was: %T`, metricBakeDaysAttribute))
	}

	metricDimensionColumnsAttribute, ok := attributes["metric_dimension_columns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_dimension_columns is missing from object`)

		return nil, diags
	}

	metricDimensionColumnsVal, ok := metricDimensionColumnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_dimension_columns expected to be basetypes.ListValue, was: %T`, metricDimensionColumnsAttribute))
	}

	metricSourceNameAttribute, ok := attributes["metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_source_name is missing from object`)

		return nil, diags
	}

	metricSourceNameVal, ok := metricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_source_name expected to be basetypes.StringValue, was: %T`, metricSourceNameAttribute))
	}

	numeratorAggregationAttribute, ok := attributes["numerator_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerator_aggregation is missing from object`)

		return nil, diags
	}

	numeratorAggregationVal, ok := numeratorAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerator_aggregation expected to be basetypes.StringValue, was: %T`, numeratorAggregationAttribute))
	}

	onlyIncludeUsersWithConversionEventAttribute, ok := attributes["only_include_users_with_conversion_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_users_with_conversion_event is missing from object`)

		return nil, diags
	}

	onlyIncludeUsersWithConversionEventVal, ok := onlyIncludeUsersWithConversionEventAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_users_with_conversion_event expected to be basetypes.BoolValue, was: %T`, onlyIncludeUsersWithConversionEventAttribute))
	}

	percentileAttribute, ok := attributes["percentile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentile is missing from object`)

		return nil, diags
	}

	percentileVal, ok := percentileAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentile expected to be basetypes.Float64Value, was: %T`, percentileAttribute))
	}

	rollupTimeWindowAttribute, ok := attributes["rollup_time_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rollup_time_window is missing from object`)

		return nil, diags
	}

	rollupTimeWindowVal, ok := rollupTimeWindowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rollup_time_window expected to be basetypes.StringValue, was: %T`, rollupTimeWindowAttribute))
	}

	valueColumnAttribute, ok := attributes["value_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_column is missing from object`)

		return nil, diags
	}

	valueColumnVal, ok := valueColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_column expected to be basetypes.StringValue, was: %T`, valueColumnAttribute))
	}

	valueThresholdAttribute, ok := attributes["value_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_threshold is missing from object`)

		return nil, diags
	}

	valueThresholdVal, ok := valueThresholdAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_threshold expected to be basetypes.Float64Value, was: %T`, valueThresholdAttribute))
	}

	waitForCohortWindowAttribute, ok := attributes["wait_for_cohort_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_cohort_window is missing from object`)

		return nil, diags
	}

	waitForCohortWindowVal, ok := waitForCohortWindowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_cohort_window expected to be basetypes.BoolValue, was: %T`, waitForCohortWindowAttribute))
	}

	winsorizationHighAttribute, ok := attributes["winsorization_high"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`winsorization_high is missing from object`)

		return nil, diags
	}

	winsorizationHighVal, ok := winsorizationHighAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`winsorization_high expected to be basetypes.Float64Value, was: %T`, winsorizationHighAttribute))
	}

	winsorizationLowAttribute, ok := attributes["winsorization_low"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`winsorization_low is missing from object`)

		return nil, diags
	}

	winsorizationLowVal, ok := winsorizationLowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`winsorization_low expected to be basetypes.Float64Value, was: %T`, winsorizationLowAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return WarehouseNativeValue{
		Aggregation:                         aggregationVal,
		AllowNullRatioDenominator:           allowNullRatioDenominatorVal,
		Cap:                                 capVal,
		Criteria:                            criteriaVal,
		CupedAttributionWindow:              cupedAttributionWindowVal,
		CustomRollUpEnd:                     customRollUpEndVal,
		CustomRollUpStart:                   customRollUpStartVal,
		DenominatorAggregation:              denominatorAggregationVal,
		DenominatorCriteria:                 denominatorCriteriaVal,
		DenominatorCustomRollupEnd:          denominatorCustomRollupEndVal,
		DenominatorCustomRollupStart:        denominatorCustomRollupStartVal,
		DenominatorMetricSourceName:         denominatorMetricSourceNameVal,
		DenominatorRollupTimeWindow:         denominatorRollupTimeWindowVal,
		DenominatorValueColumn:              denominatorValueColumnVal,
		FunnelCalculationWindow:             funnelCalculationWindowVal,
		FunnelCountDistinct:                 funnelCountDistinctVal,
		FunnelEvents:                        funnelEventsVal,
		FunnelStartCriteria:                 funnelStartCriteriaVal,
		MetricBakeDays:                      metricBakeDaysVal,
		MetricDimensionColumns:              metricDimensionColumnsVal,
		MetricSourceName:                    metricSourceNameVal,
		NumeratorAggregation:                numeratorAggregationVal,
		OnlyIncludeUsersWithConversionEvent: onlyIncludeUsersWithConversionEventVal,
		Percentile:                          percentileVal,
		RollupTimeWindow:                    rollupTimeWindowVal,
		ValueColumn:                         valueColumnVal,
		ValueThreshold:                      valueThresholdVal,
		WaitForCohortWindow:                 waitForCohortWindowVal,
		WinsorizationHigh:                   winsorizationHighVal,
		WinsorizationLow:                    winsorizationLowVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewWarehouseNativeValueNull() WarehouseNativeValue {
	return WarehouseNativeValue{
		state: attr.ValueStateNull,
	}
}

func NewWarehouseNativeValueUnknown() WarehouseNativeValue {
	return WarehouseNativeValue{
		state: attr.ValueStateUnknown,
	}
}

func NewWarehouseNativeValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (WarehouseNativeValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing WarehouseNativeValue Attribute Value",
				"While creating a WarehouseNativeValue value, a missing attribute value was detected. "+
					"A WarehouseNativeValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WarehouseNativeValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid WarehouseNativeValue Attribute Type",
				"While creating a WarehouseNativeValue value, an invalid attribute value was detected. "+
					"A WarehouseNativeValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("WarehouseNativeValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("WarehouseNativeValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra WarehouseNativeValue Attribute Value",
				"While creating a WarehouseNativeValue value, an extra attribute value was detected. "+
					"A WarehouseNativeValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra WarehouseNativeValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewWarehouseNativeValueUnknown(), diags
	}

	aggregationAttribute, ok := attributes["aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`aggregation is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	aggregationVal, ok := aggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`aggregation expected to be basetypes.StringValue, was: %T`, aggregationAttribute))
	}

	allowNullRatioDenominatorAttribute, ok := attributes["allow_null_ratio_denominator"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_null_ratio_denominator is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	allowNullRatioDenominatorVal, ok := allowNullRatioDenominatorAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_null_ratio_denominator expected to be basetypes.BoolValue, was: %T`, allowNullRatioDenominatorAttribute))
	}

	capAttribute, ok := attributes["cap"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cap is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	capVal, ok := capAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cap expected to be basetypes.Float64Value, was: %T`, capAttribute))
	}

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	cupedAttributionWindowAttribute, ok := attributes["cuped_attribution_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`cuped_attribution_window is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	cupedAttributionWindowVal, ok := cupedAttributionWindowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`cuped_attribution_window expected to be basetypes.Float64Value, was: %T`, cupedAttributionWindowAttribute))
	}

	customRollUpEndAttribute, ok := attributes["custom_roll_up_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_roll_up_end is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	customRollUpEndVal, ok := customRollUpEndAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_roll_up_end expected to be basetypes.Float64Value, was: %T`, customRollUpEndAttribute))
	}

	customRollUpStartAttribute, ok := attributes["custom_roll_up_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`custom_roll_up_start is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	customRollUpStartVal, ok := customRollUpStartAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`custom_roll_up_start expected to be basetypes.Float64Value, was: %T`, customRollUpStartAttribute))
	}

	denominatorAggregationAttribute, ok := attributes["denominator_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_aggregation is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorAggregationVal, ok := denominatorAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_aggregation expected to be basetypes.StringValue, was: %T`, denominatorAggregationAttribute))
	}

	denominatorCriteriaAttribute, ok := attributes["denominator_criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_criteria is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorCriteriaVal, ok := denominatorCriteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_criteria expected to be basetypes.ListValue, was: %T`, denominatorCriteriaAttribute))
	}

	denominatorCustomRollupEndAttribute, ok := attributes["denominator_custom_rollup_end"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_custom_rollup_end is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorCustomRollupEndVal, ok := denominatorCustomRollupEndAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_custom_rollup_end expected to be basetypes.Float64Value, was: %T`, denominatorCustomRollupEndAttribute))
	}

	denominatorCustomRollupStartAttribute, ok := attributes["denominator_custom_rollup_start"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_custom_rollup_start is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorCustomRollupStartVal, ok := denominatorCustomRollupStartAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_custom_rollup_start expected to be basetypes.Float64Value, was: %T`, denominatorCustomRollupStartAttribute))
	}

	denominatorMetricSourceNameAttribute, ok := attributes["denominator_metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_metric_source_name is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorMetricSourceNameVal, ok := denominatorMetricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_metric_source_name expected to be basetypes.StringValue, was: %T`, denominatorMetricSourceNameAttribute))
	}

	denominatorRollupTimeWindowAttribute, ok := attributes["denominator_rollup_time_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_rollup_time_window is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorRollupTimeWindowVal, ok := denominatorRollupTimeWindowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_rollup_time_window expected to be basetypes.StringValue, was: %T`, denominatorRollupTimeWindowAttribute))
	}

	denominatorValueColumnAttribute, ok := attributes["denominator_value_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`denominator_value_column is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	denominatorValueColumnVal, ok := denominatorValueColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`denominator_value_column expected to be basetypes.StringValue, was: %T`, denominatorValueColumnAttribute))
	}

	funnelCalculationWindowAttribute, ok := attributes["funnel_calculation_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_calculation_window is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	funnelCalculationWindowVal, ok := funnelCalculationWindowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_calculation_window expected to be basetypes.Float64Value, was: %T`, funnelCalculationWindowAttribute))
	}

	funnelCountDistinctAttribute, ok := attributes["funnel_count_distinct"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_count_distinct is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	funnelCountDistinctVal, ok := funnelCountDistinctAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_count_distinct expected to be basetypes.StringValue, was: %T`, funnelCountDistinctAttribute))
	}

	funnelEventsAttribute, ok := attributes["funnel_events"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_events is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	funnelEventsVal, ok := funnelEventsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_events expected to be basetypes.ListValue, was: %T`, funnelEventsAttribute))
	}

	funnelStartCriteriaAttribute, ok := attributes["funnel_start_criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`funnel_start_criteria is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	funnelStartCriteriaVal, ok := funnelStartCriteriaAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`funnel_start_criteria expected to be basetypes.StringValue, was: %T`, funnelStartCriteriaAttribute))
	}

	metricBakeDaysAttribute, ok := attributes["metric_bake_days"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_bake_days is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	metricBakeDaysVal, ok := metricBakeDaysAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_bake_days expected to be basetypes.Float64Value, was: %T`, metricBakeDaysAttribute))
	}

	metricDimensionColumnsAttribute, ok := attributes["metric_dimension_columns"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_dimension_columns is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	metricDimensionColumnsVal, ok := metricDimensionColumnsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_dimension_columns expected to be basetypes.ListValue, was: %T`, metricDimensionColumnsAttribute))
	}

	metricSourceNameAttribute, ok := attributes["metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_source_name is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	metricSourceNameVal, ok := metricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_source_name expected to be basetypes.StringValue, was: %T`, metricSourceNameAttribute))
	}

	numeratorAggregationAttribute, ok := attributes["numerator_aggregation"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`numerator_aggregation is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	numeratorAggregationVal, ok := numeratorAggregationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`numerator_aggregation expected to be basetypes.StringValue, was: %T`, numeratorAggregationAttribute))
	}

	onlyIncludeUsersWithConversionEventAttribute, ok := attributes["only_include_users_with_conversion_event"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`only_include_users_with_conversion_event is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	onlyIncludeUsersWithConversionEventVal, ok := onlyIncludeUsersWithConversionEventAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`only_include_users_with_conversion_event expected to be basetypes.BoolValue, was: %T`, onlyIncludeUsersWithConversionEventAttribute))
	}

	percentileAttribute, ok := attributes["percentile"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`percentile is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	percentileVal, ok := percentileAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`percentile expected to be basetypes.Float64Value, was: %T`, percentileAttribute))
	}

	rollupTimeWindowAttribute, ok := attributes["rollup_time_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`rollup_time_window is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	rollupTimeWindowVal, ok := rollupTimeWindowAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`rollup_time_window expected to be basetypes.StringValue, was: %T`, rollupTimeWindowAttribute))
	}

	valueColumnAttribute, ok := attributes["value_column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_column is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	valueColumnVal, ok := valueColumnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_column expected to be basetypes.StringValue, was: %T`, valueColumnAttribute))
	}

	valueThresholdAttribute, ok := attributes["value_threshold"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`value_threshold is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	valueThresholdVal, ok := valueThresholdAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`value_threshold expected to be basetypes.Float64Value, was: %T`, valueThresholdAttribute))
	}

	waitForCohortWindowAttribute, ok := attributes["wait_for_cohort_window"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`wait_for_cohort_window is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	waitForCohortWindowVal, ok := waitForCohortWindowAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`wait_for_cohort_window expected to be basetypes.BoolValue, was: %T`, waitForCohortWindowAttribute))
	}

	winsorizationHighAttribute, ok := attributes["winsorization_high"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`winsorization_high is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	winsorizationHighVal, ok := winsorizationHighAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`winsorization_high expected to be basetypes.Float64Value, was: %T`, winsorizationHighAttribute))
	}

	winsorizationLowAttribute, ok := attributes["winsorization_low"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`winsorization_low is missing from object`)

		return NewWarehouseNativeValueUnknown(), diags
	}

	winsorizationLowVal, ok := winsorizationLowAttribute.(basetypes.Float64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`winsorization_low expected to be basetypes.Float64Value, was: %T`, winsorizationLowAttribute))
	}

	if diags.HasError() {
		return NewWarehouseNativeValueUnknown(), diags
	}

	return WarehouseNativeValue{
		Aggregation:                         aggregationVal,
		AllowNullRatioDenominator:           allowNullRatioDenominatorVal,
		Cap:                                 capVal,
		Criteria:                            criteriaVal,
		CupedAttributionWindow:              cupedAttributionWindowVal,
		CustomRollUpEnd:                     customRollUpEndVal,
		CustomRollUpStart:                   customRollUpStartVal,
		DenominatorAggregation:              denominatorAggregationVal,
		DenominatorCriteria:                 denominatorCriteriaVal,
		DenominatorCustomRollupEnd:          denominatorCustomRollupEndVal,
		DenominatorCustomRollupStart:        denominatorCustomRollupStartVal,
		DenominatorMetricSourceName:         denominatorMetricSourceNameVal,
		DenominatorRollupTimeWindow:         denominatorRollupTimeWindowVal,
		DenominatorValueColumn:              denominatorValueColumnVal,
		FunnelCalculationWindow:             funnelCalculationWindowVal,
		FunnelCountDistinct:                 funnelCountDistinctVal,
		FunnelEvents:                        funnelEventsVal,
		FunnelStartCriteria:                 funnelStartCriteriaVal,
		MetricBakeDays:                      metricBakeDaysVal,
		MetricDimensionColumns:              metricDimensionColumnsVal,
		MetricSourceName:                    metricSourceNameVal,
		NumeratorAggregation:                numeratorAggregationVal,
		OnlyIncludeUsersWithConversionEvent: onlyIncludeUsersWithConversionEventVal,
		Percentile:                          percentileVal,
		RollupTimeWindow:                    rollupTimeWindowVal,
		ValueColumn:                         valueColumnVal,
		ValueThreshold:                      valueThresholdVal,
		WaitForCohortWindow:                 waitForCohortWindowVal,
		WinsorizationHigh:                   winsorizationHighVal,
		WinsorizationLow:                    winsorizationLowVal,
		state:                               attr.ValueStateKnown,
	}, diags
}

func NewWarehouseNativeValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) WarehouseNativeValue {
	object, diags := NewWarehouseNativeValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewWarehouseNativeValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t WarehouseNativeType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewWarehouseNativeValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewWarehouseNativeValueUnknown(), nil
	}

	if in.IsNull() {
		return NewWarehouseNativeValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewWarehouseNativeValueMust(WarehouseNativeValue{}.AttributeTypes(ctx), attributes), nil
}

func (t WarehouseNativeType) ValueType(ctx context.Context) attr.Value {
	return WarehouseNativeValue{}
}

var _ basetypes.ObjectValuable = WarehouseNativeValue{}

type WarehouseNativeValue struct {
	Aggregation                         basetypes.StringValue  `tfsdk:"aggregation"`
	AllowNullRatioDenominator           basetypes.BoolValue    `tfsdk:"allow_null_ratio_denominator"`
	Cap                                 basetypes.Float64Value `tfsdk:"cap"`
	Criteria                            basetypes.ListValue    `tfsdk:"criteria"`
	CupedAttributionWindow              basetypes.Float64Value `tfsdk:"cuped_attribution_window"`
	CustomRollUpEnd                     basetypes.Float64Value `tfsdk:"custom_roll_up_end"`
	CustomRollUpStart                   basetypes.Float64Value `tfsdk:"custom_roll_up_start"`
	DenominatorAggregation              basetypes.StringValue  `tfsdk:"denominator_aggregation"`
	DenominatorCriteria                 basetypes.ListValue    `tfsdk:"denominator_criteria"`
	DenominatorCustomRollupEnd          basetypes.Float64Value `tfsdk:"denominator_custom_rollup_end"`
	DenominatorCustomRollupStart        basetypes.Float64Value `tfsdk:"denominator_custom_rollup_start"`
	DenominatorMetricSourceName         basetypes.StringValue  `tfsdk:"denominator_metric_source_name"`
	DenominatorRollupTimeWindow         basetypes.StringValue  `tfsdk:"denominator_rollup_time_window"`
	DenominatorValueColumn              basetypes.StringValue  `tfsdk:"denominator_value_column"`
	FunnelCalculationWindow             basetypes.Float64Value `tfsdk:"funnel_calculation_window"`
	FunnelCountDistinct                 basetypes.StringValue  `tfsdk:"funnel_count_distinct"`
	FunnelEvents                        basetypes.ListValue    `tfsdk:"funnel_events"`
	FunnelStartCriteria                 basetypes.StringValue  `tfsdk:"funnel_start_criteria"`
	MetricBakeDays                      basetypes.Float64Value `tfsdk:"metric_bake_days"`
	MetricDimensionColumns              basetypes.ListValue    `tfsdk:"metric_dimension_columns"`
	MetricSourceName                    basetypes.StringValue  `tfsdk:"metric_source_name"`
	NumeratorAggregation                basetypes.StringValue  `tfsdk:"numerator_aggregation"`
	OnlyIncludeUsersWithConversionEvent basetypes.BoolValue    `tfsdk:"only_include_users_with_conversion_event"`
	Percentile                          basetypes.Float64Value `tfsdk:"percentile"`
	RollupTimeWindow                    basetypes.StringValue  `tfsdk:"rollup_time_window"`
	ValueColumn                         basetypes.StringValue  `tfsdk:"value_column"`
	ValueThreshold                      basetypes.Float64Value `tfsdk:"value_threshold"`
	WaitForCohortWindow                 basetypes.BoolValue    `tfsdk:"wait_for_cohort_window"`
	WinsorizationHigh                   basetypes.Float64Value `tfsdk:"winsorization_high"`
	WinsorizationLow                    basetypes.Float64Value `tfsdk:"winsorization_low"`
	state                               attr.ValueState
}

func (v WarehouseNativeValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 30)

	var val tftypes.Value
	var err error

	attrTypes["aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["allow_null_ratio_denominator"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["cap"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["criteria"] = basetypes.ListType{
		ElemType: CriteriaValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["cuped_attribution_window"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["custom_roll_up_end"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["custom_roll_up_start"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["denominator_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["denominator_criteria"] = basetypes.ListType{
		ElemType: DenominatorCriteriaValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["denominator_custom_rollup_end"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["denominator_custom_rollup_start"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["denominator_metric_source_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["denominator_rollup_time_window"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["denominator_value_column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["funnel_calculation_window"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["funnel_count_distinct"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["funnel_events"] = basetypes.ListType{
		ElemType: FunnelEventsValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["funnel_start_criteria"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["metric_bake_days"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["metric_dimension_columns"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["metric_source_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["numerator_aggregation"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["only_include_users_with_conversion_event"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["percentile"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["rollup_time_window"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["value_threshold"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["wait_for_cohort_window"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["winsorization_high"] = basetypes.Float64Type{}.TerraformType(ctx)
	attrTypes["winsorization_low"] = basetypes.Float64Type{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 30)

		val, err = v.Aggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["aggregation"] = val

		val, err = v.AllowNullRatioDenominator.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_null_ratio_denominator"] = val

		val, err = v.Cap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cap"] = val

		val, err = v.Criteria.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["criteria"] = val

		val, err = v.CupedAttributionWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["cuped_attribution_window"] = val

		val, err = v.CustomRollUpEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_roll_up_end"] = val

		val, err = v.CustomRollUpStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["custom_roll_up_start"] = val

		val, err = v.DenominatorAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_aggregation"] = val

		val, err = v.DenominatorCriteria.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_criteria"] = val

		val, err = v.DenominatorCustomRollupEnd.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_custom_rollup_end"] = val

		val, err = v.DenominatorCustomRollupStart.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_custom_rollup_start"] = val

		val, err = v.DenominatorMetricSourceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_metric_source_name"] = val

		val, err = v.DenominatorRollupTimeWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_rollup_time_window"] = val

		val, err = v.DenominatorValueColumn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["denominator_value_column"] = val

		val, err = v.FunnelCalculationWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["funnel_calculation_window"] = val

		val, err = v.FunnelCountDistinct.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["funnel_count_distinct"] = val

		val, err = v.FunnelEvents.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["funnel_events"] = val

		val, err = v.FunnelStartCriteria.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["funnel_start_criteria"] = val

		val, err = v.MetricBakeDays.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_bake_days"] = val

		val, err = v.MetricDimensionColumns.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_dimension_columns"] = val

		val, err = v.MetricSourceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_source_name"] = val

		val, err = v.NumeratorAggregation.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["numerator_aggregation"] = val

		val, err = v.OnlyIncludeUsersWithConversionEvent.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["only_include_users_with_conversion_event"] = val

		val, err = v.Percentile.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["percentile"] = val

		val, err = v.RollupTimeWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["rollup_time_window"] = val

		val, err = v.ValueColumn.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_column"] = val

		val, err = v.ValueThreshold.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["value_threshold"] = val

		val, err = v.WaitForCohortWindow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["wait_for_cohort_window"] = val

		val, err = v.WinsorizationHigh.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["winsorization_high"] = val

		val, err = v.WinsorizationLow.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["winsorization_low"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v WarehouseNativeValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v WarehouseNativeValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v WarehouseNativeValue) String() string {
	return "WarehouseNativeValue"
}

func (v WarehouseNativeValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	criteria := types.ListValueMust(
		CriteriaType{
			basetypes.ObjectType{
				AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
			},
		},
		v.Criteria.Elements(),
	)

	if v.Criteria.IsNull() {
		criteria = types.ListNull(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Criteria.IsUnknown() {
		criteria = types.ListUnknown(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	denominatorCriteria := types.ListValueMust(
		DenominatorCriteriaType{
			basetypes.ObjectType{
				AttrTypes: DenominatorCriteriaValue{}.AttributeTypes(ctx),
			},
		},
		v.DenominatorCriteria.Elements(),
	)

	if v.DenominatorCriteria.IsNull() {
		denominatorCriteria = types.ListNull(
			DenominatorCriteriaType{
				basetypes.ObjectType{
					AttrTypes: DenominatorCriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.DenominatorCriteria.IsUnknown() {
		denominatorCriteria = types.ListUnknown(
			DenominatorCriteriaType{
				basetypes.ObjectType{
					AttrTypes: DenominatorCriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	funnelEvents := types.ListValueMust(
		FunnelEventsType{
			basetypes.ObjectType{
				AttrTypes: FunnelEventsValue{}.AttributeTypes(ctx),
			},
		},
		v.FunnelEvents.Elements(),
	)

	if v.FunnelEvents.IsNull() {
		funnelEvents = types.ListNull(
			FunnelEventsType{
				basetypes.ObjectType{
					AttrTypes: FunnelEventsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.FunnelEvents.IsUnknown() {
		funnelEvents = types.ListUnknown(
			FunnelEventsType{
				basetypes.ObjectType{
					AttrTypes: FunnelEventsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	metricDimensionColumnsVal, d := types.ListValue(types.StringType, v.MetricDimensionColumns.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"aggregation":                  basetypes.StringType{},
			"allow_null_ratio_denominator": basetypes.BoolType{},
			"cap":                          basetypes.Float64Type{},
			"criteria": basetypes.ListType{
				ElemType: CriteriaValue{}.Type(ctx),
			},
			"cuped_attribution_window": basetypes.Float64Type{},
			"custom_roll_up_end":       basetypes.Float64Type{},
			"custom_roll_up_start":     basetypes.Float64Type{},
			"denominator_aggregation":  basetypes.StringType{},
			"denominator_criteria": basetypes.ListType{
				ElemType: DenominatorCriteriaValue{}.Type(ctx),
			},
			"denominator_custom_rollup_end":   basetypes.Float64Type{},
			"denominator_custom_rollup_start": basetypes.Float64Type{},
			"denominator_metric_source_name":  basetypes.StringType{},
			"denominator_rollup_time_window":  basetypes.StringType{},
			"denominator_value_column":        basetypes.StringType{},
			"funnel_calculation_window":       basetypes.Float64Type{},
			"funnel_count_distinct":           basetypes.StringType{},
			"funnel_events": basetypes.ListType{
				ElemType: FunnelEventsValue{}.Type(ctx),
			},
			"funnel_start_criteria": basetypes.StringType{},
			"metric_bake_days":      basetypes.Float64Type{},
			"metric_dimension_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"metric_source_name":                       basetypes.StringType{},
			"numerator_aggregation":                    basetypes.StringType{},
			"only_include_users_with_conversion_event": basetypes.BoolType{},
			"percentile":                               basetypes.Float64Type{},
			"rollup_time_window":                       basetypes.StringType{},
			"value_column":                             basetypes.StringType{},
			"value_threshold":                          basetypes.Float64Type{},
			"wait_for_cohort_window":                   basetypes.BoolType{},
			"winsorization_high":                       basetypes.Float64Type{},
			"winsorization_low":                        basetypes.Float64Type{},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"aggregation":                  basetypes.StringType{},
			"allow_null_ratio_denominator": basetypes.BoolType{},
			"cap":                          basetypes.Float64Type{},
			"criteria": basetypes.ListType{
				ElemType: CriteriaValue{}.Type(ctx),
			},
			"cuped_attribution_window": basetypes.Float64Type{},
			"custom_roll_up_end":       basetypes.Float64Type{},
			"custom_roll_up_start":     basetypes.Float64Type{},
			"denominator_aggregation":  basetypes.StringType{},
			"denominator_criteria": basetypes.ListType{
				ElemType: DenominatorCriteriaValue{}.Type(ctx),
			},
			"denominator_custom_rollup_end":   basetypes.Float64Type{},
			"denominator_custom_rollup_start": basetypes.Float64Type{},
			"denominator_metric_source_name":  basetypes.StringType{},
			"denominator_rollup_time_window":  basetypes.StringType{},
			"denominator_value_column":        basetypes.StringType{},
			"funnel_calculation_window":       basetypes.Float64Type{},
			"funnel_count_distinct":           basetypes.StringType{},
			"funnel_events": basetypes.ListType{
				ElemType: FunnelEventsValue{}.Type(ctx),
			},
			"funnel_start_criteria": basetypes.StringType{},
			"metric_bake_days":      basetypes.Float64Type{},
			"metric_dimension_columns": basetypes.ListType{
				ElemType: types.StringType,
			},
			"metric_source_name":                       basetypes.StringType{},
			"numerator_aggregation":                    basetypes.StringType{},
			"only_include_users_with_conversion_event": basetypes.BoolType{},
			"percentile":                               basetypes.Float64Type{},
			"rollup_time_window":                       basetypes.StringType{},
			"value_column":                             basetypes.StringType{},
			"value_threshold":                          basetypes.Float64Type{},
			"wait_for_cohort_window":                   basetypes.BoolType{},
			"winsorization_high":                       basetypes.Float64Type{},
			"winsorization_low":                        basetypes.Float64Type{},
		},
		map[string]attr.Value{
			"aggregation":                              v.Aggregation,
			"allow_null_ratio_denominator":             v.AllowNullRatioDenominator,
			"cap":                                      v.Cap,
			"criteria":                                 criteria,
			"cuped_attribution_window":                 v.CupedAttributionWindow,
			"custom_roll_up_end":                       v.CustomRollUpEnd,
			"custom_roll_up_start":                     v.CustomRollUpStart,
			"denominator_aggregation":                  v.DenominatorAggregation,
			"denominator_criteria":                     denominatorCriteria,
			"denominator_custom_rollup_end":            v.DenominatorCustomRollupEnd,
			"denominator_custom_rollup_start":          v.DenominatorCustomRollupStart,
			"denominator_metric_source_name":           v.DenominatorMetricSourceName,
			"denominator_rollup_time_window":           v.DenominatorRollupTimeWindow,
			"denominator_value_column":                 v.DenominatorValueColumn,
			"funnel_calculation_window":                v.FunnelCalculationWindow,
			"funnel_count_distinct":                    v.FunnelCountDistinct,
			"funnel_events":                            funnelEvents,
			"funnel_start_criteria":                    v.FunnelStartCriteria,
			"metric_bake_days":                         v.MetricBakeDays,
			"metric_dimension_columns":                 metricDimensionColumnsVal,
			"metric_source_name":                       v.MetricSourceName,
			"numerator_aggregation":                    v.NumeratorAggregation,
			"only_include_users_with_conversion_event": v.OnlyIncludeUsersWithConversionEvent,
			"percentile":                               v.Percentile,
			"rollup_time_window":                       v.RollupTimeWindow,
			"value_column":                             v.ValueColumn,
			"value_threshold":                          v.ValueThreshold,
			"wait_for_cohort_window":                   v.WaitForCohortWindow,
			"winsorization_high":                       v.WinsorizationHigh,
			"winsorization_low":                        v.WinsorizationLow,
		})

	return objVal, diags
}

func (v WarehouseNativeValue) Equal(o attr.Value) bool {
	other, ok := o.(WarehouseNativeValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Aggregation.Equal(other.Aggregation) {
		return false
	}

	if !v.AllowNullRatioDenominator.Equal(other.AllowNullRatioDenominator) {
		return false
	}

	if !v.Cap.Equal(other.Cap) {
		return false
	}

	if !v.Criteria.Equal(other.Criteria) {
		return false
	}

	if !v.CupedAttributionWindow.Equal(other.CupedAttributionWindow) {
		return false
	}

	if !v.CustomRollUpEnd.Equal(other.CustomRollUpEnd) {
		return false
	}

	if !v.CustomRollUpStart.Equal(other.CustomRollUpStart) {
		return false
	}

	if !v.DenominatorAggregation.Equal(other.DenominatorAggregation) {
		return false
	}

	if !v.DenominatorCriteria.Equal(other.DenominatorCriteria) {
		return false
	}

	if !v.DenominatorCustomRollupEnd.Equal(other.DenominatorCustomRollupEnd) {
		return false
	}

	if !v.DenominatorCustomRollupStart.Equal(other.DenominatorCustomRollupStart) {
		return false
	}

	if !v.DenominatorMetricSourceName.Equal(other.DenominatorMetricSourceName) {
		return false
	}

	if !v.DenominatorRollupTimeWindow.Equal(other.DenominatorRollupTimeWindow) {
		return false
	}

	if !v.DenominatorValueColumn.Equal(other.DenominatorValueColumn) {
		return false
	}

	if !v.FunnelCalculationWindow.Equal(other.FunnelCalculationWindow) {
		return false
	}

	if !v.FunnelCountDistinct.Equal(other.FunnelCountDistinct) {
		return false
	}

	if !v.FunnelEvents.Equal(other.FunnelEvents) {
		return false
	}

	if !v.FunnelStartCriteria.Equal(other.FunnelStartCriteria) {
		return false
	}

	if !v.MetricBakeDays.Equal(other.MetricBakeDays) {
		return false
	}

	if !v.MetricDimensionColumns.Equal(other.MetricDimensionColumns) {
		return false
	}

	if !v.MetricSourceName.Equal(other.MetricSourceName) {
		return false
	}

	if !v.NumeratorAggregation.Equal(other.NumeratorAggregation) {
		return false
	}

	if !v.OnlyIncludeUsersWithConversionEvent.Equal(other.OnlyIncludeUsersWithConversionEvent) {
		return false
	}

	if !v.Percentile.Equal(other.Percentile) {
		return false
	}

	if !v.RollupTimeWindow.Equal(other.RollupTimeWindow) {
		return false
	}

	if !v.ValueColumn.Equal(other.ValueColumn) {
		return false
	}

	if !v.ValueThreshold.Equal(other.ValueThreshold) {
		return false
	}

	if !v.WaitForCohortWindow.Equal(other.WaitForCohortWindow) {
		return false
	}

	if !v.WinsorizationHigh.Equal(other.WinsorizationHigh) {
		return false
	}

	if !v.WinsorizationLow.Equal(other.WinsorizationLow) {
		return false
	}

	return true
}

func (v WarehouseNativeValue) Type(ctx context.Context) attr.Type {
	return WarehouseNativeType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v WarehouseNativeValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"aggregation":                  basetypes.StringType{},
		"allow_null_ratio_denominator": basetypes.BoolType{},
		"cap":                          basetypes.Float64Type{},
		"criteria": basetypes.ListType{
			ElemType: CriteriaValue{}.Type(ctx),
		},
		"cuped_attribution_window": basetypes.Float64Type{},
		"custom_roll_up_end":       basetypes.Float64Type{},
		"custom_roll_up_start":     basetypes.Float64Type{},
		"denominator_aggregation":  basetypes.StringType{},
		"denominator_criteria": basetypes.ListType{
			ElemType: DenominatorCriteriaValue{}.Type(ctx),
		},
		"denominator_custom_rollup_end":   basetypes.Float64Type{},
		"denominator_custom_rollup_start": basetypes.Float64Type{},
		"denominator_metric_source_name":  basetypes.StringType{},
		"denominator_rollup_time_window":  basetypes.StringType{},
		"denominator_value_column":        basetypes.StringType{},
		"funnel_calculation_window":       basetypes.Float64Type{},
		"funnel_count_distinct":           basetypes.StringType{},
		"funnel_events": basetypes.ListType{
			ElemType: FunnelEventsValue{}.Type(ctx),
		},
		"funnel_start_criteria": basetypes.StringType{},
		"metric_bake_days":      basetypes.Float64Type{},
		"metric_dimension_columns": basetypes.ListType{
			ElemType: types.StringType,
		},
		"metric_source_name":                       basetypes.StringType{},
		"numerator_aggregation":                    basetypes.StringType{},
		"only_include_users_with_conversion_event": basetypes.BoolType{},
		"percentile":                               basetypes.Float64Type{},
		"rollup_time_window":                       basetypes.StringType{},
		"value_column":                             basetypes.StringType{},
		"value_threshold":                          basetypes.Float64Type{},
		"wait_for_cohort_window":                   basetypes.BoolType{},
		"winsorization_high":                       basetypes.Float64Type{},
		"winsorization_low":                        basetypes.Float64Type{},
	}
}

var _ basetypes.ObjectTypable = CriteriaType{}

type CriteriaType struct {
	basetypes.ObjectType
}

func (t CriteriaType) Equal(o attr.Type) bool {
	other, ok := o.(CriteriaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CriteriaType) String() string {
	return "CriteriaType"
}

func (t CriteriaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return nil, diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return nil, diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueNull() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateNull,
	}
}

func NewCriteriaValueUnknown() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCriteriaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CriteriaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, a missing attribute value was detected. "+
					"A CriteriaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CriteriaValue Attribute Type",
				"While creating a CriteriaValue value, an invalid attribute value was detected. "+
					"A CriteriaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, an extra attribute value was detected. "+
					"A CriteriaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CriteriaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CriteriaValue {
	object, diags := NewCriteriaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCriteriaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CriteriaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCriteriaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCriteriaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCriteriaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCriteriaValueMust(CriteriaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CriteriaType) ValueType(ctx context.Context) attr.Value {
	return CriteriaValue{}
}

var _ basetypes.ObjectValuable = CriteriaValue{}

type CriteriaValue struct {
	Column              basetypes.StringValue `tfsdk:"column"`
	Condition           basetypes.StringValue `tfsdk:"condition"`
	NullVacuousOverride basetypes.BoolValue   `tfsdk:"null_vacuous_override"`
	CriteriaType        basetypes.StringValue `tfsdk:"type"`
	Values              basetypes.ListValue   `tfsdk:"values"`
	state               attr.ValueState
}

func (v CriteriaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["null_vacuous_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Column.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["column"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.NullVacuousOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["null_vacuous_override"] = val

		val, err = v.CriteriaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CriteriaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CriteriaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CriteriaValue) String() string {
	return "CriteriaValue"
}

func (v CriteriaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	valuesVal, d := types.ListValue(types.StringType, v.Values.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"column":                v.Column,
			"condition":             v.Condition,
			"null_vacuous_override": v.NullVacuousOverride,
			"type":                  v.CriteriaType,
			"values":                valuesVal,
		})

	return objVal, diags
}

func (v CriteriaValue) Equal(o attr.Value) bool {
	other, ok := o.(CriteriaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Column.Equal(other.Column) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.NullVacuousOverride.Equal(other.NullVacuousOverride) {
		return false
	}

	if !v.CriteriaType.Equal(other.CriteriaType) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v CriteriaValue) Type(ctx context.Context) attr.Type {
	return CriteriaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CriteriaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"column":                basetypes.StringType{},
		"condition":             basetypes.StringType{},
		"null_vacuous_override": basetypes.BoolType{},
		"type":                  basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = DenominatorCriteriaType{}

type DenominatorCriteriaType struct {
	basetypes.ObjectType
}

func (t DenominatorCriteriaType) Equal(o attr.Type) bool {
	other, ok := o.(DenominatorCriteriaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DenominatorCriteriaType) String() string {
	return "DenominatorCriteriaType"
}

func (t DenominatorCriteriaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return nil, diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return nil, diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DenominatorCriteriaValue{
		Column:                  columnVal,
		Condition:               conditionVal,
		NullVacuousOverride:     nullVacuousOverrideVal,
		DenominatorCriteriaType: typeVal,
		Values:                  valuesVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDenominatorCriteriaValueNull() DenominatorCriteriaValue {
	return DenominatorCriteriaValue{
		state: attr.ValueStateNull,
	}
}

func NewDenominatorCriteriaValueUnknown() DenominatorCriteriaValue {
	return DenominatorCriteriaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDenominatorCriteriaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DenominatorCriteriaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DenominatorCriteriaValue Attribute Value",
				"While creating a DenominatorCriteriaValue value, a missing attribute value was detected. "+
					"A DenominatorCriteriaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DenominatorCriteriaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DenominatorCriteriaValue Attribute Type",
				"While creating a DenominatorCriteriaValue value, an invalid attribute value was detected. "+
					"A DenominatorCriteriaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DenominatorCriteriaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DenominatorCriteriaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DenominatorCriteriaValue Attribute Value",
				"While creating a DenominatorCriteriaValue value, an extra attribute value was detected. "+
					"A DenominatorCriteriaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DenominatorCriteriaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDenominatorCriteriaValueUnknown(), diags
	}

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return NewDenominatorCriteriaValueUnknown(), diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewDenominatorCriteriaValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return NewDenominatorCriteriaValueUnknown(), diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewDenominatorCriteriaValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewDenominatorCriteriaValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewDenominatorCriteriaValueUnknown(), diags
	}

	return DenominatorCriteriaValue{
		Column:                  columnVal,
		Condition:               conditionVal,
		NullVacuousOverride:     nullVacuousOverrideVal,
		DenominatorCriteriaType: typeVal,
		Values:                  valuesVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewDenominatorCriteriaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DenominatorCriteriaValue {
	object, diags := NewDenominatorCriteriaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDenominatorCriteriaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DenominatorCriteriaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDenominatorCriteriaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDenominatorCriteriaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDenominatorCriteriaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDenominatorCriteriaValueMust(DenominatorCriteriaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DenominatorCriteriaType) ValueType(ctx context.Context) attr.Value {
	return DenominatorCriteriaValue{}
}

var _ basetypes.ObjectValuable = DenominatorCriteriaValue{}

type DenominatorCriteriaValue struct {
	Column                  basetypes.StringValue `tfsdk:"column"`
	Condition               basetypes.StringValue `tfsdk:"condition"`
	NullVacuousOverride     basetypes.BoolValue   `tfsdk:"null_vacuous_override"`
	DenominatorCriteriaType basetypes.StringValue `tfsdk:"type"`
	Values                  basetypes.ListValue   `tfsdk:"values"`
	state                   attr.ValueState
}

func (v DenominatorCriteriaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["null_vacuous_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Column.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["column"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.NullVacuousOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["null_vacuous_override"] = val

		val, err = v.DenominatorCriteriaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DenominatorCriteriaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DenominatorCriteriaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DenominatorCriteriaValue) String() string {
	return "DenominatorCriteriaValue"
}

func (v DenominatorCriteriaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	valuesVal, d := types.ListValue(types.StringType, v.Values.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"column":                v.Column,
			"condition":             v.Condition,
			"null_vacuous_override": v.NullVacuousOverride,
			"type":                  v.DenominatorCriteriaType,
			"values":                valuesVal,
		})

	return objVal, diags
}

func (v DenominatorCriteriaValue) Equal(o attr.Value) bool {
	other, ok := o.(DenominatorCriteriaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Column.Equal(other.Column) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.NullVacuousOverride.Equal(other.NullVacuousOverride) {
		return false
	}

	if !v.DenominatorCriteriaType.Equal(other.DenominatorCriteriaType) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v DenominatorCriteriaValue) Type(ctx context.Context) attr.Type {
	return DenominatorCriteriaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DenominatorCriteriaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"column":                basetypes.StringType{},
		"condition":             basetypes.StringType{},
		"null_vacuous_override": basetypes.BoolType{},
		"type":                  basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = FunnelEventsType{}

type FunnelEventsType struct {
	basetypes.ObjectType
}

func (t FunnelEventsType) Equal(o attr.Type) bool {
	other, ok := o.(FunnelEventsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t FunnelEventsType) String() string {
	return "FunnelEventsType"
}

func (t FunnelEventsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return nil, diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	metricSourceNameAttribute, ok := attributes["metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_source_name is missing from object`)

		return nil, diags
	}

	metricSourceNameVal, ok := metricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_source_name expected to be basetypes.StringValue, was: %T`, metricSourceNameAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sessionIdentifierFieldAttribute, ok := attributes["session_identifier_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_identifier_field is missing from object`)

		return nil, diags
	}

	sessionIdentifierFieldVal, ok := sessionIdentifierFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_identifier_field expected to be basetypes.StringValue, was: %T`, sessionIdentifierFieldAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return FunnelEventsValue{
		Criteria:               criteriaVal,
		MetricSourceName:       metricSourceNameVal,
		Name:                   nameVal,
		SessionIdentifierField: sessionIdentifierFieldVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewFunnelEventsValueNull() FunnelEventsValue {
	return FunnelEventsValue{
		state: attr.ValueStateNull,
	}
}

func NewFunnelEventsValueUnknown() FunnelEventsValue {
	return FunnelEventsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewFunnelEventsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (FunnelEventsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing FunnelEventsValue Attribute Value",
				"While creating a FunnelEventsValue value, a missing attribute value was detected. "+
					"A FunnelEventsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FunnelEventsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid FunnelEventsValue Attribute Type",
				"While creating a FunnelEventsValue value, an invalid attribute value was detected. "+
					"A FunnelEventsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("FunnelEventsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("FunnelEventsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra FunnelEventsValue Attribute Value",
				"While creating a FunnelEventsValue value, an extra attribute value was detected. "+
					"A FunnelEventsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra FunnelEventsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewFunnelEventsValueUnknown(), diags
	}

	criteriaAttribute, ok := attributes["criteria"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`criteria is missing from object`)

		return NewFunnelEventsValueUnknown(), diags
	}

	criteriaVal, ok := criteriaAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`criteria expected to be basetypes.ListValue, was: %T`, criteriaAttribute))
	}

	metricSourceNameAttribute, ok := attributes["metric_source_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`metric_source_name is missing from object`)

		return NewFunnelEventsValueUnknown(), diags
	}

	metricSourceNameVal, ok := metricSourceNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`metric_source_name expected to be basetypes.StringValue, was: %T`, metricSourceNameAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewFunnelEventsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	sessionIdentifierFieldAttribute, ok := attributes["session_identifier_field"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`session_identifier_field is missing from object`)

		return NewFunnelEventsValueUnknown(), diags
	}

	sessionIdentifierFieldVal, ok := sessionIdentifierFieldAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`session_identifier_field expected to be basetypes.StringValue, was: %T`, sessionIdentifierFieldAttribute))
	}

	if diags.HasError() {
		return NewFunnelEventsValueUnknown(), diags
	}

	return FunnelEventsValue{
		Criteria:               criteriaVal,
		MetricSourceName:       metricSourceNameVal,
		Name:                   nameVal,
		SessionIdentifierField: sessionIdentifierFieldVal,
		state:                  attr.ValueStateKnown,
	}, diags
}

func NewFunnelEventsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) FunnelEventsValue {
	object, diags := NewFunnelEventsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewFunnelEventsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t FunnelEventsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewFunnelEventsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewFunnelEventsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewFunnelEventsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewFunnelEventsValueMust(FunnelEventsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t FunnelEventsType) ValueType(ctx context.Context) attr.Value {
	return FunnelEventsValue{}
}

var _ basetypes.ObjectValuable = FunnelEventsValue{}

type FunnelEventsValue struct {
	Criteria               basetypes.ListValue   `tfsdk:"criteria"`
	MetricSourceName       basetypes.StringValue `tfsdk:"metric_source_name"`
	Name                   basetypes.StringValue `tfsdk:"name"`
	SessionIdentifierField basetypes.StringValue `tfsdk:"session_identifier_field"`
	state                  attr.ValueState
}

func (v FunnelEventsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["criteria"] = basetypes.ListType{
		ElemType: CriteriaValue{}.Type(ctx),
	}.TerraformType(ctx)
	attrTypes["metric_source_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["session_identifier_field"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.Criteria.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["criteria"] = val

		val, err = v.MetricSourceName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["metric_source_name"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.SessionIdentifierField.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["session_identifier_field"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v FunnelEventsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v FunnelEventsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v FunnelEventsValue) String() string {
	return "FunnelEventsValue"
}

func (v FunnelEventsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	criteria := types.ListValueMust(
		CriteriaType{
			basetypes.ObjectType{
				AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
			},
		},
		v.Criteria.Elements(),
	)

	if v.Criteria.IsNull() {
		criteria = types.ListNull(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Criteria.IsUnknown() {
		criteria = types.ListUnknown(
			CriteriaType{
				basetypes.ObjectType{
					AttrTypes: CriteriaValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"criteria": basetypes.ListType{
				ElemType: CriteriaValue{}.Type(ctx),
			},
			"metric_source_name":       basetypes.StringType{},
			"name":                     basetypes.StringType{},
			"session_identifier_field": basetypes.StringType{},
		},
		map[string]attr.Value{
			"criteria":                 criteria,
			"metric_source_name":       v.MetricSourceName,
			"name":                     v.Name,
			"session_identifier_field": v.SessionIdentifierField,
		})

	return objVal, diags
}

func (v FunnelEventsValue) Equal(o attr.Value) bool {
	other, ok := o.(FunnelEventsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Criteria.Equal(other.Criteria) {
		return false
	}

	if !v.MetricSourceName.Equal(other.MetricSourceName) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.SessionIdentifierField.Equal(other.SessionIdentifierField) {
		return false
	}

	return true
}

func (v FunnelEventsValue) Type(ctx context.Context) attr.Type {
	return FunnelEventsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v FunnelEventsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"criteria": basetypes.ListType{
			ElemType: CriteriaValue{}.Type(ctx),
		},
		"metric_source_name":       basetypes.StringType{},
		"name":                     basetypes.StringType{},
		"session_identifier_field": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = CriteriaType{}

type CriteriaType struct {
	basetypes.ObjectType
}

func (t CriteriaType) Equal(o attr.Type) bool {
	other, ok := o.(CriteriaType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t CriteriaType) String() string {
	return "CriteriaType"
}

func (t CriteriaType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return nil, diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return nil, diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return nil, diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return nil, diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return nil, diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueNull() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateNull,
	}
}

func NewCriteriaValueUnknown() CriteriaValue {
	return CriteriaValue{
		state: attr.ValueStateUnknown,
	}
}

func NewCriteriaValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (CriteriaValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, a missing attribute value was detected. "+
					"A CriteriaValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid CriteriaValue Attribute Type",
				"While creating a CriteriaValue value, an invalid attribute value was detected. "+
					"A CriteriaValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("CriteriaValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra CriteriaValue Attribute Value",
				"While creating a CriteriaValue value, an extra attribute value was detected. "+
					"A CriteriaValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra CriteriaValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	columnAttribute, ok := attributes["column"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`column is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	columnVal, ok := columnAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`column expected to be basetypes.StringValue, was: %T`, columnAttribute))
	}

	conditionAttribute, ok := attributes["condition"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`condition is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	conditionVal, ok := conditionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`condition expected to be basetypes.StringValue, was: %T`, conditionAttribute))
	}

	nullVacuousOverrideAttribute, ok := attributes["null_vacuous_override"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`null_vacuous_override is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	nullVacuousOverrideVal, ok := nullVacuousOverrideAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`null_vacuous_override expected to be basetypes.BoolValue, was: %T`, nullVacuousOverrideAttribute))
	}

	typeAttribute, ok := attributes["type"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`type is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	typeVal, ok := typeAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`type expected to be basetypes.StringValue, was: %T`, typeAttribute))
	}

	valuesAttribute, ok := attributes["values"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`values is missing from object`)

		return NewCriteriaValueUnknown(), diags
	}

	valuesVal, ok := valuesAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`values expected to be basetypes.ListValue, was: %T`, valuesAttribute))
	}

	if diags.HasError() {
		return NewCriteriaValueUnknown(), diags
	}

	return CriteriaValue{
		Column:              columnVal,
		Condition:           conditionVal,
		NullVacuousOverride: nullVacuousOverrideVal,
		CriteriaType:        typeVal,
		Values:              valuesVal,
		state:               attr.ValueStateKnown,
	}, diags
}

func NewCriteriaValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) CriteriaValue {
	object, diags := NewCriteriaValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewCriteriaValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t CriteriaType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewCriteriaValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewCriteriaValueUnknown(), nil
	}

	if in.IsNull() {
		return NewCriteriaValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewCriteriaValueMust(CriteriaValue{}.AttributeTypes(ctx), attributes), nil
}

func (t CriteriaType) ValueType(ctx context.Context) attr.Value {
	return CriteriaValue{}
}

var _ basetypes.ObjectValuable = CriteriaValue{}

type CriteriaValue struct {
	Column              basetypes.StringValue `tfsdk:"column"`
	Condition           basetypes.StringValue `tfsdk:"condition"`
	NullVacuousOverride basetypes.BoolValue   `tfsdk:"null_vacuous_override"`
	CriteriaType        basetypes.StringValue `tfsdk:"type"`
	Values              basetypes.ListValue   `tfsdk:"values"`
	state               attr.ValueState
}

func (v CriteriaValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 5)

	var val tftypes.Value
	var err error

	attrTypes["column"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["condition"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["null_vacuous_override"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["type"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["values"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 5)

		val, err = v.Column.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["column"] = val

		val, err = v.Condition.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["condition"] = val

		val, err = v.NullVacuousOverride.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["null_vacuous_override"] = val

		val, err = v.CriteriaType.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["type"] = val

		val, err = v.Values.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["values"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v CriteriaValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v CriteriaValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v CriteriaValue) String() string {
	return "CriteriaValue"
}

func (v CriteriaValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	valuesVal, d := types.ListValue(types.StringType, v.Values.Elements())

	diags.Append(d...)

	if d.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		}), diags
	}

	objVal, diags := types.ObjectValue(
		map[string]attr.Type{
			"column":                basetypes.StringType{},
			"condition":             basetypes.StringType{},
			"null_vacuous_override": basetypes.BoolType{},
			"type":                  basetypes.StringType{},
			"values": basetypes.ListType{
				ElemType: types.StringType,
			},
		},
		map[string]attr.Value{
			"column":                v.Column,
			"condition":             v.Condition,
			"null_vacuous_override": v.NullVacuousOverride,
			"type":                  v.CriteriaType,
			"values":                valuesVal,
		})

	return objVal, diags
}

func (v CriteriaValue) Equal(o attr.Value) bool {
	other, ok := o.(CriteriaValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Column.Equal(other.Column) {
		return false
	}

	if !v.Condition.Equal(other.Condition) {
		return false
	}

	if !v.NullVacuousOverride.Equal(other.NullVacuousOverride) {
		return false
	}

	if !v.CriteriaType.Equal(other.CriteriaType) {
		return false
	}

	if !v.Values.Equal(other.Values) {
		return false
	}

	return true
}

func (v CriteriaValue) Type(ctx context.Context) attr.Type {
	return CriteriaType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v CriteriaValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"column":                basetypes.StringType{},
		"condition":             basetypes.StringType{},
		"null_vacuous_override": basetypes.BoolType{},
		"type":                  basetypes.StringType{},
		"values": basetypes.ListType{
			ElemType: types.StringType,
		},
	}
}
